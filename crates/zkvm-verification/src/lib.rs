//! security critical verification for zkVm integration

extern crate alloc;
use core::fmt::Debug;
use kona_client::single::FaultProofProgramError;
use kona_preimage::{CommsClient, PreimageKey};
use kona_proof::{l1::OracleBlobProvider, BootInfo, FlushableCache};

use hokulea_client::fp_client;
use hokulea_proof::{
    canoe_verifier::CanoeVerifier, eigenda_blob_witness::EigenDABlobWitnessData,
    preloaded_eigenda_provider::PreloadedEigenDABlobProvider,
};

use alloc::sync::Arc;
use tracing::info;

use alloy_consensus::Header;
use alloy_evm::{EvmFactory, FromRecoveredTx, FromTxWithEncoded};
use alloy_rlp::Decodable;
use op_alloy_consensus::OpTxEnvelope;
use op_revm::OpSpecId;

// By this time,both Oracle and EigenDABlobWitnessData are generated by some party that runs run_witgen_client.
// This party now needs to send both of them as inputs to ZKVM. So imagine wit and oracle are sent away, and
// the code region below are some codes that runs inside ZKVM. The ZKVM will convert EigenDABlobWitnessData into
// a preloaded eigenda provider, that implements the trait get_blob. The run_fp_client are also run inside zkVM
#[allow(clippy::type_complexity)]
pub async fn run_within_zkvm<O, Evm>(
    oracle: Arc<O>,
    evm_factory: Evm,
    canoe_verifier: impl CanoeVerifier,
    mut witness: EigenDABlobWitnessData,
) -> Result<(), FaultProofProgramError>
where
    O: CommsClient + FlushableCache + Send + Sync + Debug,
    Evm: EvmFactory<Spec = OpSpecId> + Send + Sync + Debug + Clone + 'static,
    <Evm as EvmFactory>::Tx: FromTxWithEncoded<OpTxEnvelope> + FromRecoveredTx<OpTxEnvelope>,
{
    info!("start the code supposed to run inside zkVM");
    let beacon = OracleBlobProvider::new(oracle.clone());
    let boot_info = BootInfo::load(oracle.as_ref()).await?;

    // get l1 block number, must come from oracle directly
    let header_rlp = oracle
        .get(PreimageKey::new_keccak256(*boot_info.l1_head))
        .await
        .expect("get l1 header based on l1 head");
    // Decode the header RLP into a Header.
    let l1_head_header = Header::decode(&mut header_rlp.as_slice()).expect("rlp decode l1 header");

    // it is critical that some field of the witness is populated inside the zkVM using the source
    // of truth within the zkVM
    let num_cert = witness.validity.len();
    for i in 0..num_cert {
        witness.validity[i].l1_head_block_hash = boot_info.l1_head;
        witness.validity[i].l1_head_block_number = l1_head_header.number;
    }

    // verify all the eigenda blobs
    let preloaded_blob_provider =
        PreloadedEigenDABlobProvider::from_witness(witness, canoe_verifier);

    // this is replaced by fault proof client developed by zkVM team
    fp_client::run_fp_client(oracle, beacon, preloaded_blob_provider, evm_factory).await?;

    Ok(())
}
