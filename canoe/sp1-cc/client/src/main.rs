#![no_main]
sp1_zkvm::entrypoint!(main);

use alloy_primitives::{keccak256, Address};
use alloy_sol_types::{sol_data::Bool, SolType};
use canoe_bindings::{Journal, StatusCode};
use canoe_provider::{CanoeInput, CertVerifierCall};
use sp1_cc_client_executor::{io::EvmSketchInput, AnchorType, ClientExecutor, ContractInput};

pub fn main() {
    // Read the state sketch from stdin. Use this during the execution in order to
    // access Ethereum state.
    let state_sketch_bytes = sp1_zkvm::io::read::<Vec<u8>>();
    let state_sketch = bincode::deserialize::<EvmSketchInput>(&state_sketch_bytes)
        .expect("should be able to deserialize evm sketch state");

    // read a list of canoe inputs and prove them all together in one sp1-cc proof
    let canoe_inputs = sp1_zkvm::io::read::<Vec<CanoeInput>>();

    // ensure all canoe_proof uses identical l1 chain id and l1 head block number
    assert!(!canoe_inputs.is_empty());

    let l1_chain_id_from_canoe_input = canoe_inputs[0].l1_chain_id;
    let l1_head_block_number = canoe_inputs[0].l1_head_block_number;
    let l1_head_block_hash = canoe_inputs[0].l1_head_block_hash;
    // require all canoe input share a common l1_chain_id
    for canoe_input in canoe_inputs.iter() {
        assert!(canoe_input.l1_chain_id == l1_chain_id_from_canoe_input);
        assert!(canoe_input.l1_head_block_number == l1_head_block_number);
        assert!(canoe_input.l1_head_block_hash == l1_head_block_hash);
    }

    // generate digest of rsp genesis from state sketch
    let rsp_genesis_bytes =
        bincode::serialize(&state_sketch.genesis).expect("should be able to serialize rsp genesis");
    let rsp_genesis_hash = keccak256(rsp_genesis_bytes);

    // Initialize the client executor with the state sketch.
    // This step also validates all of the storage against state root provided by the host
    let executor =
        ClientExecutor::eth(&state_sketch).expect("should be able to initialize client executor");

    // l1_head_block_number identical to executor's number
    assert_eq!(l1_head_block_number, executor.header.number);

    // l1_chain_id is committed to the journal that would be compared aginast the journal generated by
    // the hokulea program. Chain ID is checked implicitly
    let l1_chain_id = executor.chain_spec.chain().id();
    assert!(l1_chain_id_from_canoe_input == l1_chain_id);

    // Those journals are pushed into a vector and later serialized in a byte array which can be committed
    // by the zkVM. To verify if zkVM has produced the proof for the exact serialized journals, canoe verifier
    // verifies the zkVM proof against the commited journals.
    let mut journals: Vec<Journal> = vec![];
    // executes all calls, then combines and commits all journals
    for canoe_input in canoe_inputs.iter() {
        let (returns, anchor_hash, anchor_type, chain_config_hash) =
            match CertVerifierCall::build(&canoe_input.altda_commitment) {
                CertVerifierCall::LegacyV2Interface(call) => {
                    let call = ContractInput::new_call(
                        canoe_input.verifier_address,
                        Address::default(),
                        call,
                    );

                    let public_vals = executor
                        .execute(call)
                        .expect("executor should be able to execute call");

                    // empricially if the function reverts, the output is empty, the guest code abort when evm revert takes place
                    let validity = Bool::abi_decode(&public_vals.contractOutput)
                        .expect("should be able to deserialize returns");
                    (
                        validity,
                        public_vals.anchorHash,
                        public_vals.anchorType,
                        public_vals.chainConfigHash,
                    )
                }
                CertVerifierCall::ABIEncodeInterface(call) => {
                    let call = ContractInput::new_call(
                        canoe_input.verifier_address,
                        Address::default(),
                        call,
                    );

                    let public_vals = executor
                        .execute(call)
                        .expect("executor should be able to execute call");

                    match <StatusCode as SolType>::abi_decode(&public_vals.contractOutput) {
                        Ok(returns) => {
                            let validity = returns == StatusCode::SUCCESS;
                            (
                                validity,
                                public_vals.anchorHash,
                                public_vals.anchorType,
                                public_vals.chainConfigHash,
                            )
                        }
                        Err(_) => {
                            // if the returned uint8 cannot be parsed into StatusCode, that implies
                            // the value must be larger than 1, that means the contract isn't successful.
                            // This could happen if onchain contract returns more status code, and offchain
                            // does not update properly. To alleviate the issue, we always convert any
                            // unrecognized status code to false
                            (
                                false,
                                public_vals.anchorHash,
                                public_vals.anchorType,
                                public_vals.chainConfigHash,
                            )
                        }
                    }
                }
            };

        // make sure the anchor type is block hash
        let AnchorType::BlockHash = anchor_type else {
            panic!("sp1-cc expects anchor type of BlockHash");
        };

        let rlp_bytes = canoe_input.altda_commitment.to_rlp_bytes();

        // check the claimed validity equals to the evaluation result from sp1-cc
        assert!(canoe_input.claimed_validity == returns);

        assert!(anchor_hash == l1_head_block_hash);

        let journal = Journal {
            blockNumber: l1_head_block_number,
            certVerifierAddress: canoe_input.verifier_address,
            input: rlp_bytes.into(),
            blockhash: anchor_hash,
            output: returns,
            l1ChainId: l1_chain_id,
            chainSpecHash: rsp_genesis_hash,
            chainConfigHash: chain_config_hash,
        };
        journals.push(journal);
    }

    // use bincode to serialize, such that it can be deserialized to parse the commited content. All the
    // material are vector, and said to be deterministic.
    // bincode is also used in op-succinct aggregate program
    // https://github.com/succinctlabs/op-succinct/blob/c30c5a083fdc7e2da99ece249ca2fffb7d2498e5/programs/aggregation/src/main.rs#L43
    let journals_bytes = bincode::serialize(&journals).expect("should be able to serialize");

    // Commit journals altogether
    sp1_zkvm::io::commit_slice(&journals_bytes);
}
